#今天是崩溃的一天只因为一个printf
##Windows下DEVC++ 5.11 的printf函数对参数的执行顺序
i++和++i在printf中的神奇操作
---
```

	#include<stdio.h>
	
	int main()
	{
		int i=3;
		printf("%d, %d, %d, %d\n",i++,i++,i++,i++);
		printf("i is %d\n",i);
		return 0;
	}
```

输出是6543而第二次输出的i是7

这是为什么呢

真相只有一个：printf从右往左压入i，i压入后加一

而++i就厉害了
```

	int i=3;
	printf("%d, %d, %d, %d\n",++i,++i,++i,++i);

```

结果是7777

看了csdn的大佬解释：对于a++的结果，是有ebp寻址函数栈空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；
而对于++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。
这就是a++和++a的压栈的区别。

大概意思就是++i 和 i 都是将 i 的地址压入栈，而 i++ 是将自加前的 i 的副本压入栈

++i 和 i 都是经过一系列骚操作后 i 的值，而 i++ 则是将其入栈时 i 的副本，所以 i++ 只是显示当时 i 的值。

##vc++6.0的printf函数对参数的执行顺序
直接上代码分析分析
```

	int i=2; 
	printf("%d,%d,%d,%d,\n",i++,++i,i,i++); 
	printf("%d\n",i);
 
```

本段代码在VC++6.0中的规则如下： 

1、printf函数的入栈顺序也是是由右到左的
 
2、前自增运算符（++i）先加1，更新后再使用i，此时i已经加了1； 

3、后自增运算符（i++）先使用i，再加1，但这里就是关键所在，VC++6.0后自增运算是要在**整条语句结束**以后才自加1的。

（注：printf函数的计算也是从右向左进行的。）


